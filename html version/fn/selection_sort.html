<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Selection Sort â€“ Step by Step</title>

<link rel="stylesheet" href="styles.css">

</head>

<body>

<!-- LEFT PANEL -->
<div class="explain">
  <b>Selection Sort</b><br><br>
  â€¢ Find the smallest number in unsorted part<br>
  â€¢ Swap it with the first unsorted position<br>
  â€¢ Mark that position as sorted<br>
  â€¢ Repeat until all elements are sorted<br>
  â€¢ Builds sorted array from the left to right âœ…
</div>

<!-- CENTER PANEL -->
<div class="center">
  <div class="iteration-label" id="iterLabel">
    Click "Next Step" to start
  </div>

  <div class="container" id="container">
  </div>

  <div class="buttons">
    <button id="prevStep">Previous Step</button>
    <button id="nextStep">Next Step</button>
    <button id="newArray">New Array</button>
  </div>

  <div class="explanation-text" id="explanationText">
    Ready to begin sorting
  </div>
</div>

<!-- RIGHT PANEL - CODE -->
<div class="code" id="codeBlock">
  <div class="language-selector">
    <select class="lang-dropdown" id="langSelect">
      <option value="cpp">C++</option>
      <option value="python">Python</option>
      <option value="pseudo">Pseudocode</option>
    </select>
  </div>
</div>

<script>
// CODE TEMPLATES FOR SELECTION SORT
const CODE_TEMPLATES = {
  cpp: [
    '#include <iostream>',
    'using namespace std;',
    '',
    'int main() {',
    '    int arr[] = {5, 3, 8, 4, 2};',
    '    int n = 5;',
    '',
    '    for (int i = 0; i < n - 1; i++) {',
    '        int minIdx = i;',
    '        for (int j = i + 1; j < n; j++) {',
    '            if (arr[j] < arr[minIdx]) {',
    '                minIdx = j;',
    '            }',
    '        }',
    '        swap(arr[i], arr[minIdx]);',
    '    }',
    '    return 0;',
    '}'
  ],
  python: [
    'def selection_sort(arr):',
    '    n = len(arr)',
    '    for i in range(n - 1):',
    '        min_idx = i',
    '        for j in range(i + 1, n):',
    '            if arr[j] < arr[min_idx]:',
    '                min_idx = j',
    '        arr[i], arr[min_idx] = arr[min_idx], arr[i]',
    '',
    '',
    'arr = [5, 3, 8, 4, 2]',
    'selection_sort(arr)'
  ],
  pseudo: [
    'ALGORITHM SelectionSort(arr):',
    '    n â† length of arr',
    '',
    '    FOR i FROM 0 TO n-2 DO:',
    '        minIdx â† i',
    '        FOR j FROM i+1 TO n-1 DO:',
    '            IF arr[j] < arr[minIdx] THEN:',
    '                minIdx â† j',
    '            END IF',
    '        END FOR',
    '        SWAP arr[i] with arr[minIdx]',
    '    END FOR',
    '',
    'END ALGORITHM'
  ]
};

// LINE NUMBERS TO HIGHLIGHT FOR EACH LANGUAGE
const HIGHLIGHT_LINES = {
  cpp: { outer: 7, minInit: 8, inner: 9, compare: 10, swap: 14 },
  python: { outer: 2, minInit: 3, inner: 4, compare: 5, swap: 7 },
  pseudo: { outer: 3, minInit: 4, inner: 5, compare: 6, swap: 10 }
};

// STATE VARIABLES
let currentLanguage = 'cpp';
let arr = [];
let history = [];

// Selection Sort State
let state = {
  i: 0,           // Current position being filled with minimum
  j: 0,           // Current position being scanned
  minIdx: 0,      // Index of minimum element found so far
  phase: 'init',  // Phases: 'init', 'scanning', 'swap', 'complete'
  sorted: false
};

// DOM ELEMENTS
const container = document.getElementById('container');
const iterLabel = document.getElementById('iterLabel');
const nextBtn = document.getElementById('nextStep');
const prevBtn = document.getElementById('prevStep');
const newBtn = document.getElementById('newArray');
const codeBlock = document.getElementById('codeBlock');
const langSelect = document.getElementById('langSelect');
const explanationText = document.getElementById('explanationText');

// LANGUAGE SELECTOR EVENT
langSelect.addEventListener('change', (e) => {
  currentLanguage = e.target.value;
  renderCode();
});

// GENERATE UNIQUE RANDOM ARRAY
function randomArray() {
  const numbers = [];
  const usedNumbers = new Set();
  
  while (numbers.length < 8) {
    const num = 1 + Math.floor(Math.random() * 20);
    if (!usedNumbers.has(num)) {
      usedNumbers.add(num);
      numbers.push(num);
    }
  }
  
  return numbers;
}

// RENDER ARRAY VISUALIZATION
function renderArray() {
  // Save language selector before clearing
  const langSelector = document.querySelector('.language-selector');
  const langSelectorParent = langSelector ? langSelector.parentElement : null;
  
  container.innerHTML = '';
  
  arr.forEach((value, index) => {
    const item = document.createElement('div');
    item.className = 'item';
    item.dataset.index = index;

    const arrow = document.createElement('div');
    arrow.className = 'arrow';
    arrow.textContent = 'â†“';

    const idx = document.createElement('div');
    idx.className = 'index';
    idx.textContent = index;

    const bar = document.createElement('div');
    bar.className = 'bar';
    bar.textContent = value;
    bar.style.setProperty('--height', value * 12 + 'px');

    // Apply styles based on state
    if (state.sorted) {
      // All sorted
      bar.classList.add('sorted');
    } else {
      // Add iteration glow
      if (state.i < arr.length) {
        bar.classList.add(`iter-${state.i}`);
      }

      // Mark sorted elements (0 to i-1)
      if (index < state.i) {
        bar.classList.add('sorted');
      }
      // Mark current minimum
      else if (index === state.minIdx && state.phase === 'scanning') {
        bar.classList.add('minimum');
        arrow.style.visibility = 'visible';
      }
      // Mark current element being scanned
      else if (index === state.j && state.phase === 'scanning') {
        bar.classList.add('comparing');
        arrow.style.visibility = 'visible';
      }
      // Mark elements being swapped
      else if (state.phase === 'swap' && (index === state.i || index === state.minIdx)) {
        bar.classList.add('comparing');
        arrow.style.visibility = 'visible';
      }
    }

    item.append(arrow, idx, bar);
    container.appendChild(item);
  });
  
  // Add sorted divider if there are sorted elements
  if (!state.sorted && state.i > 0 && state.i < arr.length) {
    const items = [...container.children];
    if (items.length > 0) {
      const divider = document.createElement('div');
      divider.className = 'sorted-divider';
      divider.style.opacity = '0';
      
      container.appendChild(divider);
      
      setTimeout(() => {
        const leftItem = items[state.i - 1];
        const rightItem = items[state.i];
        
        if (leftItem && rightItem) {
          const leftRect = leftItem.getBoundingClientRect();
          const rightRect = rightItem.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          const dividerLeft = ((leftRect.right + rightRect.left) / 2) - containerRect.left;
          divider.style.left = dividerLeft + 'px';
          divider.style.opacity = '1';
        }
      }, 0);
    }
  }
}

// RENDER CODE WITH HIGHLIGHTING
function renderCode(highlightLine = null) {
  const lines = CODE_TEMPLATES[currentLanguage];
  const langSelector = document.querySelector('.language-selector');
  
  let html = '';
  lines.forEach((line, idx) => {
    const isHighlight = highlightLine === idx;
    html += `<div class="code-line ${isHighlight ? 'highlight' : ''}">${line || '&nbsp;'}</div>`;
  });
  
  codeBlock.innerHTML = html;
  
  // Re-append language selector
  if (langSelector) {
    codeBlock.appendChild(langSelector);
  }
}

// UPDATE ITERATION LABEL
function updateIterationLabel() {
  if (state.sorted) {
    iterLabel.textContent = 'âœ… Array is sorted!';
    iterLabel.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
    iterLabel.style.color = 'white';
  } else {
    const passNum = state.i + 1;
    
    if (state.phase === 'init') {
      iterLabel.textContent = `ðŸ”„ Pass ${passNum} - Initializing minimum at position ${state.i}`;
    } else if (state.phase === 'scanning') {
      iterLabel.textContent = `ðŸ” Pass ${passNum} - Scanning position ${state.j} (min at ${state.minIdx})`;
    } else if (state.phase === 'swap') {
      iterLabel.textContent = `ðŸ”„ Pass ${passNum} - Swapping positions ${state.i} and ${state.minIdx}`;
    }
    
    iterLabel.style.background = getIterationColor(state.i);
    iterLabel.style.color = 'white';
    iterLabel.classList.add('active');
    setTimeout(() => iterLabel.classList.remove('active'), 500);
  }
}

// GET ITERATION COLOR
function getIterationColor(iterNum) {
  const colors = [
    'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)',
    'linear-gradient(135deg, #ff9f40 0%, #ff6b6b 100%)',
    'linear-gradient(135deg, #ffce56 0%, #ff9f40 100%)',
    'linear-gradient(135deg, #4bc0c0 0%, #36a2a2 100%)',
    'linear-gradient(135deg, #9966ff 0%, #7b4fff 100%)',
    'linear-gradient(135deg, #ff6384 0%, #ff4f7c 100%)',
    'linear-gradient(135deg, #36a2eb 0%, #258dcf 100%)',
    'linear-gradient(135deg, #ff9fef 0%, #e67be0 100%)'
  ];
  return colors[iterNum % colors.length];
}

// FLIP SWAP ANIMATION
function flipSwap(indexA, indexB, callback) {
  const items = [...container.children].filter(child => child.classList.contains('item'));
  const itemA = items[indexA];
  const itemB = items[indexB];
  
  if (!itemA || !itemB) {
    if (callback) callback();
    return;
  }

  const rectA = itemA.getBoundingClientRect();
  const rectB = itemB.getBoundingClientRect();

  // Swap in DOM
  if (indexA < indexB) {
    container.insertBefore(itemB, itemA);
  } else {
    container.insertBefore(itemA, itemB);
  }

  const rectA2 = itemA.getBoundingClientRect();
  const rectB2 = itemB.getBoundingClientRect();

  const dxA = rectA.left - rectA2.left;
  const dxB = rectB.left - rectB2.left;

  itemA.style.transform = `translateX(${dxA}px)`;
  itemB.style.transform = `translateX(${dxB}px)`;

  requestAnimationFrame(() => {
    itemA.style.transition = 'transform 0.6s ease';
    itemB.style.transition = 'transform 0.6s ease';
    itemA.style.transform = '';
    itemB.style.transform = '';
  });

  setTimeout(() => {
    itemA.style.transition = '';
    itemB.style.transition = '';
    if (callback) callback();
  }, 600);
}

// SAVE STATE TO HISTORY
function saveState() {
  history.push({
    arr: [...arr],
    state: { ...state },
    iterLabelText: iterLabel.textContent,
    iterLabelBg: iterLabel.style.background,
    iterLabelColor: iterLabel.style.color,
    explanationTextContent: explanationText.textContent
  });
}

// RESET TO INITIAL STATE
function reset() {
  arr = randomArray();
  state = {
    i: 0,
    j: 0,
    minIdx: 0,
    phase: 'init',
    sorted: false
  };
  history = [];
  
  nextBtn.disabled = false;
  prevBtn.disabled = true;
  
  iterLabel.textContent = 'Click "Next Step" to start';
  iterLabel.style.background = 'white';
  iterLabel.style.color = '#333';
  explanationText.textContent = 'Ready to begin sorting';
  
  renderArray();
  renderCode();
}

// NEXT STEP BUTTON
nextBtn.addEventListener('click', () => {
  if (state.sorted) return;
  
  const lines = HIGHLIGHT_LINES[currentLanguage];
  
  // Save current state before making changes
  saveState();
  
  // Check if sorting is complete
  if (state.i >= arr.length - 1) {
    state.sorted = true;
    nextBtn.disabled = true;
    iterLabel.textContent = 'âœ… Sorting Complete!';
    iterLabel.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
    iterLabel.style.color = 'white';
    explanationText.textContent = 'All elements are now in their correct positions!';
    renderArray();
    renderCode();
    prevBtn.disabled = false;
    return;
  }
  
  // STATE MACHINE FOR SELECTION SORT
  if (state.phase === 'init') {
    // Initialize minIdx to current i
    state.minIdx = state.i;
    state.j = state.i + 1;
    state.phase = 'scanning';
    
    updateIterationLabel();
    renderCode(lines.minInit);
    explanationText.textContent = `Starting pass ${state.i + 1}: Assume minimum is at position ${state.i} (value ${arr[state.i]})`;
    renderArray();
    prevBtn.disabled = false;
  }
  else if (state.phase === 'scanning') {
    // Scanning for minimum
    if (state.j < arr.length) {
      updateIterationLabel();
      renderCode(lines.compare);
      
      const currentVal = arr[state.j];
      const minVal = arr[state.minIdx];
      
      if (currentVal < minVal) {
        state.minIdx = state.j;
        explanationText.textContent = `Found smaller value ${currentVal} at position ${state.j} - updating minimum`;
      } else {
        explanationText.textContent = `Value ${currentVal} at position ${state.j} is not smaller than current min ${minVal}`;
      }
      
      renderArray();
      state.j++;
      prevBtn.disabled = false;
    } else {
      // Finished scanning, prepare for swap
      state.phase = 'swap';
      updateIterationLabel();
      renderCode(lines.swap);
      
      if (state.i === state.minIdx) {
        explanationText.textContent = `Minimum ${arr[state.minIdx]} is already at position ${state.i} - no swap needed`;
      } else {
        explanationText.textContent = `Swapping minimum ${arr[state.minIdx]} from position ${state.minIdx} with position ${state.i}`;
      }
      
      renderArray();
      prevBtn.disabled = false;
    }
  }
  else if (state.phase === 'swap') {
    // Perform swap if needed
    if (state.i !== state.minIdx) {
      const temp = arr[state.i];
      arr[state.i] = arr[state.minIdx];
      arr[state.minIdx] = temp;
      
      nextBtn.disabled = true;
      prevBtn.disabled = true;
      
      flipSwap(state.i, state.minIdx, () => {
        // Move to next pass
        state.i++;
        state.j = state.i + 1;
        state.minIdx = state.i;
        state.phase = 'init';
        
        nextBtn.disabled = false;
        prevBtn.disabled = false;
        
        renderArray();
      });
    } else {
      // No swap needed, move to next pass
      state.i++;
      state.j = state.i + 1;
      state.minIdx = state.i;
      state.phase = 'init';
      
      renderArray();
    }
  }
});

// PREVIOUS STEP BUTTON
prevBtn.addEventListener('click', () => {
  if (history.length === 0) return;
  
  const prevState = history.pop();
  
  arr = prevState.arr;
  state = prevState.state;
  
  iterLabel.textContent = prevState.iterLabelText;
  iterLabel.style.background = prevState.iterLabelBg;
  iterLabel.style.color = prevState.iterLabelColor;
  explanationText.textContent = prevState.explanationTextContent;
  
  nextBtn.disabled = false;
  
  if (history.length === 0) {
    prevBtn.disabled = true;
  }
  
  renderArray();
  renderCode();
});

// NEW ARRAY BUTTON
newBtn.addEventListener('click', reset);

// INITIALIZE
reset();
</script>

</body>
</html>